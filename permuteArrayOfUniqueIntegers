import java.util.ArrayList;

public class PermutationGenerator {
    public static void main(String[] args) {
        int[] a = {1, 2, 3};
        ArrayList<Integer> inputList = new ArrayList<>();
        for (int i : a) {
            inputList.add(i);
        }
        ArrayList<ArrayList<Integer>> resultList = new ArrayList<>();
        permutationHelper(inputList, new ArrayList<Integer>(), resultList);
        for (ArrayList<Integer> permutation : resultList) {
            System.out.println(permutation);
        }
    }

    private static void permutationHelper(ArrayList<Integer> inputList, ArrayList<Integer> currentPermutation, ArrayList<ArrayList<Integer>> resultList) {
        // Base case: If no elements left in inputList, add current permutation to result
        if (inputList.size() == 0) {
            resultList.add(new ArrayList<>(currentPermutation));
            return;
        }
        // Try each element from inputList as the next element in permutation
        for (int i = 0; i < inputList.size(); i++) {
            // Include the current element
            currentPermutation.add(inputList.get(i));
            // Create a new list excluding the current element
            ArrayList<Integer> remainingList = new ArrayList<>(inputList);
            remainingList.remove(i);
            // Recurse with the remaining elements
            permutationHelper(remainingList, currentPermutation, resultList);
            // Backtrack by removing the last added element
            currentPermutation.remove(currentPermutation.size() - 1);
        }
    }
}

Time complexity:

Recursive Calls:
In the permutation generation algorithm, we iterate through each element in the input array and generate permutations with the remaining elements.
This leads to a recursive structure where, for each element, we have 
n choices to consider.
First Element: 
n choices
Second Element: 
n−1 choices (one element is already used)
Third Element: 
n−2 choices
... and so on.
The total number of recursive calls is the product of these choices:
n×(n−1)×(n−2)×…×2×1=n!

The time complexity is O(n!) because the number of recursive calls grows factorially with the size of the input array. 

Spacecomplexity:

Total Space Complexity:
The total space complexity is the sum of the space used by these components.

Space Complexity=Space Used by Call Stack+Space Used by ArrayLists

Space Complexity=O(n)+O(n) ie O(n)
